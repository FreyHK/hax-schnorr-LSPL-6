(**
  This file contains the Hax lemmas defined in the Rust code.
  As these lemmas have already been proven, this file simply 
  uses the already proven lemmas to prove them.
*)

(* File automatically generated by Hacspec *)
From Coq Require Import ZArith.
Require Import List.
Import List.ListNotations.
Open Scope Z_scope.
Open Scope bool_scope.
Require Import Ascii.
Require Import String.
Require Import Coq.Floats.Floats.
From RecordUpdate Require Import RecordSet.
Import RecordSetNotations.
From Core Require Import Core.

(* NotImplementedYet *)

From Schnorr Require Import Schnorr_Point.
From Schnorr Require Import Schnorr_Elliptic_curve.
From Schnorr Require Import Schnorr_Abstract_structures.
From Schnorr Require Import Schnorr_Schnorr.

(* Set Printing All. *)


Lemma ec_add_closed 
  `{v_F : Type} `{v_S : Type} 
  `{t_Sized (v_F)} `{t_Sized (v_S)}
  `{t_Field v_F} `{t_Scalar v_S} 
  (curve : t_EllipticCurve v_F v_S) 
  (p : t_Point v_F) (q : t_Point v_F) :
  implb (andb (impl__is_on_curve (curve) (p)) (impl__is_on_curve (curve) (q))) (
    impl__is_on_curve (curve) (impl__add (curve) (p) (q))) = true.
Proof.
  apply Bool.implb_true_iff.
  intros.
  apply Bool.andb_true_iff in H10.
  destruct H10 as [Hp Hq].
  apply ec_add_closed; auto.
Qed.

Lemma ec_neg_closed `{v_F : Type} `{v_S : Type} `{t_Sized (v_F)} `{t_Sized (v_S)} `{t_Field (v_F)} `{t_Scalar (v_S)} (curve : t_EllipticCurve ((v_F)) ((v_S))) (p : t_Point ((v_F))) :
  implb (impl__is_on_curve (curve) (p)) (
    impl__is_on_curve (curve) (impl__neg (curve) (p))) = true.
Proof.
  apply Bool.implb_true_iff.
  intros.
  apply ec_neg_closed; auto.
Qed.

Lemma ec_mul_closed `{v_F : Type} `{v_S : Type} `{t_Sized (v_F)} `{t_Sized (v_S)} `{t_Field (v_F)} `{t_Scalar (v_S)} (curve : t_EllipticCurve ((v_F)) ((v_S))) (p : t_Point ((v_F))) (x : v_S) :
  implb (impl__is_on_curve (curve) (p)) (
    impl__is_on_curve (curve) (impl__mul (curve) (p) (x))) = true.
Proof.
  apply Bool.implb_true_iff.
  intros.
  apply ec_mul_closed; auto.
Qed.

Lemma ec_add_inf_r `{v_F : Type} `{v_S : Type} `{t_Sized (v_F)} `{t_Sized (v_S)} `{t_Field (v_F)} `{t_Scalar (v_S)} (curve : t_EllipticCurve ((v_F)) ((v_S))) (p : t_Point ((v_F))) :
  PartialEq_f_eq (impl__add (curve) (p) (Point_Infinity)) (p) = true.
Proof.
  apply p_eq_iff_partial_eq.
  apply ec_add_inf_r.
Qed.

Lemma ec_add_neg_r `{v_F : Type} `{v_S : Type} `{t_Sized (v_F)} `{t_Sized (v_S)} `{t_Field (v_F)} `{t_Scalar (v_S)} (curve : t_EllipticCurve ((v_F)) ((v_S))) (p : t_Point ((v_F))) :
  implb (impl__is_on_curve (curve) (p)) (PartialEq_f_eq (impl__add (curve) (p) (impl__neg (curve) (p))) (Point_Infinity)) = true.
Proof.
  apply Bool.implb_true_iff.
  intros.
  apply p_eq_iff_partial_eq.
  apply ec_add_neg_l.
  assumption.
Qed.

Lemma ec_add_comm `{v_F : Type} `{v_S : Type} `{t_Sized (v_F)} `{t_Sized (v_S)} `{t_Field (v_F)} `{t_Scalar (v_S)} (curve : t_EllipticCurve ((v_F)) ((v_S))) (p : t_Point ((v_F))) (q : t_Point ((v_F))) :
  implb (andb (impl__is_on_curve (curve) (p)) (impl__is_on_curve (curve) (q))) (
    PartialEq_f_eq (impl__add (curve) (p) (q)) (impl__add (curve) (q) (p))) = true.
Proof.
  apply Bool.implb_true_iff.
  intros.
  apply Bool.andb_true_iff in H10.
  destruct H10 as [Hp Hq].
  apply p_eq_iff_partial_eq.
  apply ec_add_comm.
  assumption.
  assumption.
Qed.

Lemma ec_add_assoc `{v_F : Type} `{v_S : Type} `{t_Sized (v_F)} `{t_Sized (v_S)} `{t_Field (v_F)} `{t_Scalar (v_S)} (curve : t_EllipticCurve ((v_F)) ((v_S))) (p : t_Point ((v_F))) (q : t_Point ((v_F))) (r : t_Point ((v_F))) :
  implb (andb (andb (impl__is_on_curve (curve) (p)) (impl__is_on_curve (curve) (q))) (impl__is_on_curve (curve) (r))) (
    PartialEq_f_eq (impl__add (curve) (impl__add (curve) (p) (q)) (r)) (impl__add (curve) (p) (impl__add (curve) (q) (r)))) = true.
Proof. Admitted.

Lemma ec_mul_distr `{v_F : Type} `{v_S : Type} `{t_Sized (v_F)} `{t_Sized (v_S)} `{t_Field (v_F)} `{t_Scalar (v_S)} (curve : t_EllipticCurve ((v_F)) ((v_S))) (x : v_S) (y : v_S) :
  PartialEq_f_eq (impl__mul (curve) (impl__generator (curve)) (f_add (x) (y))) (impl__add (curve) (impl__mul (curve) (impl__generator (curve)) (x)) (impl__mul (curve) (impl__generator (curve)) (y))) = true.
Proof.
  apply p_eq_iff_partial_eq.
  apply ec_gen_mul_add_distr.
Qed.

Lemma ec_mul_mul `{v_F : Type} `{v_S : Type} `{t_Sized (v_F)} `{t_Sized (v_S)} `{t_Field (v_F)} `{t_Scalar (v_S)} (curve : t_EllipticCurve ((v_F)) ((v_S))) (x : v_S) (y : v_S) :
  PartialEq_f_eq (impl__mul (curve) (impl__generator (curve)) (f_mul (x) (y))) (impl__mul (curve) (impl__mul (curve) (impl__generator (curve)) (x)) (y)) = true.
Proof. 
  apply p_eq_iff_partial_eq.
  symmetry.
  apply ec_gen_mul_mul.
Qed.

Lemma verification_correctness `{v_F : Type} `{v_S : Type} `{t_Sized (v_F)} `{t_Sized (v_S)} `{t_Field (v_F)} `{t_Scalar (v_S)} (curve : t_EllipticCurve ((v_F)) ((v_S))) (a : v_S) (v : v_S) (c : v_S) (r : v_S) :
  let v_A := gen_key (curve) (a) in
  let v_V := commitment (curve) (v) in
  let c := challenge (curve) (c) in
  implb 
    (PartialEq_f_ne (a) (f_zero (tt))) 
      (andb 
        (implb (PartialEq_f_eq (r) (respond (v) (a) (c))) (verify (curve) (v_V) (v_A) (r) (c))) 
        (implb (verify (curve) (v_V) (v_A) (r) (c)) (PartialEq_f_eq (r) (respond (v) (a) (c))))) 
      = true.
Proof.
  pose proof (schnorr_correctness v_S v_F _ curve a v c r) as Hs.
  simpl in *.
  rewrite Bool.implb_true_iff.
  rewrite Bool.andb_true_iff.
  intros.
  rewrite Bool.implb_true_iff.
  rewrite Bool.implb_true_iff.
  unfold challenge in *.
  rewrite clone_id in *. 
  apply paritalNe_iff_ne in H10.
  apply Hs in H10. 
  clear Hs.
  repeat split.
  - intros. 
    apply partialEq_iff_eq in H11.
    apply H10. apply H11.
  - intros.
    apply partialEq_iff_eq.
    apply H10.
    apply H11.
Qed. 

Lemma schnorr_soundness_aux `{v_F : Type} `{v_S : Type} `{t_Sized (v_F)} `{t_Sized (v_S)} `{t_Field (v_F)} `{t_Scalar (v_S)} (curve : t_EllipticCurve ((v_F)) ((v_S))) (a : v_S) (v : v_S) (r1 : v_S) (r2 : v_S) (c1 : v_S) (c2 : v_S) :
  let v_A := gen_key (curve) (a) in
  let v_V := commitment (curve) (v) in
  let c1 := challenge (curve) (c1) in
  let c2 := challenge (curve) (c2) in
  implb (andb (andb 
    (verify (curve) (v_V) (v_A) (r1) (c1)) 
    (verify (curve) (v_V) (v_A) (r2) (c2))) 
    (PartialEq_f_ne (c1) (c2)))
    (PartialEq_f_eq (a) (f_div (f_sub (r1) (r2)) (f_sub (c2) (c1)))) 
  = true.
Proof.
  simpl.
  apply Bool.implb_true_iff.
  intros.
  apply Bool.andb_true_iff in H10.
  destruct H10 as [Hver1 Hver2].
  apply partialEq_iff_eq.
  unfold challenge in *.
  rewrite clone_id in *.
  rewrite clone_id in *.
  apply Bool.andb_true_iff in Hver1.
  destruct Hver1 as [Hver1 Hver3].
  apply (schnorr_soundness v_S v_F H4 curve r1 r2 c1 c2 a v).
  apply paritalNe_iff_ne in Hver2.
  apply Hver2.
  apply Hver1.
  apply Hver3.
Qed.

