(**
  This file contains the Hax extraction of the schnorr protocol implementation
  and prove the completeness property and a lemma used in the proof of the soundness
  property. 
*)


(* File automatically generated by Hacspec *)
From Coq Require Import ZArith.
Require Import List.
Import List.ListNotations.
Open Scope Z_scope.
Open Scope bool_scope.
Require Import Ascii.
Require Import String.
Require Import Coq.Floats.Floats.
From RecordUpdate Require Import RecordSet.
Import RecordSetNotations.
From Core Require Import Core.

(* NotImplementedYet *)

From Schnorr Require Import Schnorr_Abstract_structures.
From Schnorr Require Import Schnorr_Elliptic_curve.
From Schnorr Require Import Schnorr_Point.
From Schnorr Require Import Binary_Nums.

Definition gen_key 
  `{v_F : Type} `{v_S : Type} 
  `{t_Sized v_F} `{t_Sized v_S} 
  `{t_Field v_F} `{t_Scalar v_S} 
  (curve : t_EllipticCurve v_F v_S) 
  (a : v_S) : t_Point v_F :=
  let v_G := impl__generator curve in
  impl__mul curve v_G a.

Definition commitment 
  `{v_F : Type} `{v_S : Type} 
  `{t_Sized v_F} `{t_Sized v_S} 
  `{t_Field v_F} `{t_Scalar v_S} 
  (curve : t_EllipticCurve v_F v_S) 
  (v : v_S) : t_Point v_F :=
  let v_G := impl__generator curve in
  impl__mul curve v_G v.

Definition challenge 
  `{v_F : Type} `{v_S : Type} 
  `{t_Sized v_F} `{t_Sized v_S} 
  `{t_Field v_F} `{t_Scalar v_S} 
  (curve : t_EllipticCurve v_F v_S)
  (c : v_S) : v_S :=
  Clone_f_clone c.

Definition respond 
  `{v_F : Type} `{v_S : Type} 
  `{t_Sized v_F} `{t_Sized v_S} 
  `{t_Field v_F} `{t_Scalar v_S} 
  (v a c : v_S) : v_S :=
  f_sub (v) (f_mul (a) (c)).

Definition verify 
  `{v_F : Type} `{v_S : Type} 
  `{t_Sized v_F} `{t_Sized v_S} 
  `{t_Field v_F} `{t_Scalar v_S} 
  (curve : t_EllipticCurve v_F v_S) 
  (v_V v_A : t_Point v_F) (r c : v_S) : bool :=
  let v_A_is_on_curve := impl__is_on_curve (curve) (v_A) in
  let v_A_h := impl__mul (curve) (v_A) (impl__h (curve)) in
  let v_G_r := impl__mul (curve) (impl__generator (curve)) (r) in
  let v_A_c := impl__mul (curve) (v_A) (c) in
  let v_G_r_plus_A_c := impl__add (curve) (v_G_r) (v_A_c) in
  andb (andb (v_A_is_on_curve) (PartialEq_f_ne (v_A_h) (Point_Infinity))) (PartialEq_f_eq (v_V) (v_G_r_plus_A_c)).


Section Schnorr.

Variable A : Type.  
Context {t_Sized_A : t_Sized A}.
Context {t_Clone_A : t_Clone A}.
Context {t_PartialEq_A : Core_Cmp.t_PartialEq A A}.
Context {field_A : @t_Field A t_Sized_A t_PartialEq_A t_Clone_A}.
Context {scalar_A : @t_Scalar A t_Sized_A t_PartialEq_A t_Clone_A field_A}.

Variable F : Type.
Context {t_Sized_F : t_Sized F}.
Context {t_Clone_F : t_Clone F}.
Context {t_PartialEq_F : Core_Cmp.t_PartialEq F F}.
Variable field_F : @t_Field F t_Sized_F t_PartialEq_F t_Clone_F.

Variable curve : t_EllipticCurve F A.

Declare Scope ec_scope.

(** Notation *)
Notation "'G'" := (impl__generator curve) (at level 0): ec_scope.
Notation "'h'" := (impl__h curve) (at level 0): ec_scope.

Notation "x + y" := (impl__add curve x y) (at level 50, left associativity) : ec_scope.
Notation "x * [ y ]" := (impl__mul curve x y) (at level 40, left associativity) : ec_scope.
Notation "- x" := (impl__neg curve x) (at level 35, right associativity) : ec_scope.

Open Scope ec_scope.


(**
  Strengthened Completeness Property: The verifier will
  accept the proof transcript (V, c, r) if and only if 
  the prover followed the protocol and
  computed r correctly
*)
Theorem schnorr_correctness
  (a v c r : A) :
  a <> f_zero tt ->
  let A := gen_key curve a in
  let V := commitment curve v in
  let c' := challenge curve c in
  r = respond v a c <->
  verify curve V A r c' = true.
Proof.
  simpl.
  unfold verify, gen_key, commitment, challenge, respond.
  rewrite clone_id.
  split.
  - intros Hr. 
    apply andb_true_intro; split.
    + apply andb_true_intro; split.
      * apply ec_mul_closed.
        apply gen_is_on_curve.
      * apply p_neq_iff_partial_ne.
        apply ec_gen_mul_cofactor.
        apply H.
    + apply p_eq_iff_partial_eq.
      subst.
      rewrite ec_gen_mul_mul.
      rewrite <- ec_mul_gen_add_distr by apply g_is_on_curve.
      rewrite add_sub_eq.
      rewrite <- add_assoc.
      rewrite (add_comm _ (f_mul a c)).
      rewrite add_neg_l.
      rewrite add_comm.
      rewrite add_zero_l.
      reflexivity.
  - intros Hv. 
    apply Bool.andb_true_iff in Hv as [Hh Hr].
    apply Bool.andb_true_iff in Hh as [Ha Hh].
    apply p_eq_iff_partial_eq in Hr.
    apply p_neq_iff_partial_ne in Hh.
    rewrite ec_gen_mul_mul in Hr.
    rewrite <- ec_mul_gen_add_distr in Hr by apply g_is_on_curve.
    apply ec_mul_eq_iff_mod_n in Hr.
    rewrite Hr.
    rewrite add_sub_eq.
    rewrite <- add_assoc.
    rewrite add_neg_l.
    rewrite add_comm.
    rewrite add_zero_l.
    reflexivity.
Qed.


(**
    Helper Lemma for the soundness proof. This lemma states that
    if the prover can generate two valid responses
    (r1, c1) and (r2, c2) for the same commitment V and key A,
    then the prover can compute the secret key a
*)
Theorem schnorr_soundness 
  (r1 r2 c1 c2 a v: A) :
  let A := gen_key curve a in
  let V := commitment curve v in
  c1 <> c2 ->
  verify curve V A r1 c1 = true ->
  verify curve V A r2 c2 = true ->
  a = f_div (f_sub r1 r2) (f_sub c2 c1).
Proof.
  simpl; intros Hc H H0.
  unfold verify in H.
  unfold verify in H0.
  apply Bool.andb_true_iff in H as [_ H].
  apply Bool.andb_true_iff in H0 as [_ H0].
  apply p_eq_iff_partial_eq in H.
  apply p_eq_iff_partial_eq in H0.
  rewrite H0 in H; clear H0.
  unfold gen_key in H.
  rewrite ec_gen_mul_mul in H.
  rewrite ec_gen_mul_mul in H.
  apply ec_add_move_r in H. 
  apply eq_sym in H.
  rewrite ec_add_assoc in H.
  apply ec_add_move_l in H.
  rewrite ec_neg_gen_mul in H.
  rewrite ec_neg_gen_mul in H.
  rewrite <- ec_mul_gen_add_distr in H by apply g_is_on_curve.
  rewrite <- ec_mul_gen_add_distr in H by apply g_is_on_curve.
  apply ec_mul_eq_iff_mod_n in H.
  rewrite (add_comm (f_neg r1) r2) in H.
  rewrite <- add_sub_eq in H.
  rewrite <- add_sub_eq in H.
  rewrite <- mul_sub_distr in H.
  apply mul_div_move_r in H.
  rewrite div_sub_comm in H.
  apply H.
  - apply not_eq_sym. apply Hc.
  - apply neq_iff_diff_neq_zero. apply Hc.
  - apply ec_mul_closed. apply gen_is_on_curve.
  - apply ec_add_closed.
    + apply ec_mul_closed. apply gen_is_on_curve.
    + apply ec_neg_closed. apply ec_mul_closed. apply gen_is_on_curve.
  - apply ec_mul_closed. apply gen_is_on_curve.
  - apply ec_mul_closed. apply gen_is_on_curve.
  - apply ec_mul_closed. apply gen_is_on_curve.
  - apply ec_neg_closed. apply ec_mul_closed. apply gen_is_on_curve.
  - apply ec_mul_closed. apply gen_is_on_curve.
  - apply ec_mul_closed. apply gen_is_on_curve.
  - apply ec_add_closed.
    + apply ec_mul_closed. apply gen_is_on_curve.
    + apply ec_mul_closed. apply gen_is_on_curve.
Qed. 


End Schnorr.
