(* File automatically generated by Hacspec *)
From Coq Require Import ZArith.
Require Import List.
Import List.ListNotations.
Open Scope Z_scope.
Open Scope bool_scope.
Require Import Ascii.
Require Import String.
Require Import Coq.Floats.Floats.
From RecordUpdate Require Import RecordSet.
Import RecordSetNotations.
From Core Require Import Core.

(* NotImplementedYet *)

(** Point definition *)
Inductive t_Point (v_N : Type) `{t_Sized (v_N)} : Type :=
| Point_Infinity
| Point_Affine : v_N -> v_N -> _.
Arguments Point_Infinity {_} {_}.
Arguments Point_Affine {_} {_}.

(** Define type class instances for point  *)
Instance t_PartialEq_527405312 `{v_N : Type} `{t_Sized (v_N)} `{t_PartialEq (v_N) (v_N)} : t_PartialEq ((t_Point ((v_N)))) ((t_Point ((v_N)))) :=
  {
    PartialEq_f_eq := fun  (self : t_Point ((v_N))) (other : t_Point ((v_N)))=>
      match (self,other) with
      | (Point_Infinity,Point_Infinity) =>
        (true : bool)
      | (Point_Affine (x1) (y1),Point_Affine (x2) (y2)) =>
        andb (PartialEq_f_eq (x1) (x2)) (PartialEq_f_eq (y1) (y2))
      | _ =>
        (false : bool)
      end;
    PartialEq_f_ne := fun  (self : t_Point ((v_N))) (other : t_Point ((v_N)))=>
      negb (match (self,other) with
      | (Point_Infinity,Point_Infinity) =>
        (true : bool)
      | (Point_Affine (x1) (y1),Point_Affine (x2) (y2)) =>
        andb (PartialEq_f_eq (x1) (x2)) (PartialEq_f_eq (y1) (y2))
      | _ =>
        (false : bool)
      end);
  }.

Instance t_Clone_604343718 `{v_N : Type} `{t_Sized (v_N)} `{t_Clone (v_N)} : t_Clone ((t_Point ((v_N)))) :=
  {
    Clone_f_clone := fun  (self : t_Point ((v_N)))=>
      match self with
      | Point_Infinity =>  Point_Infinity
      | Point_Affine (x) (y) => Point_Affine (Clone_f_clone (x)) (Clone_f_clone (y))
      end;
  }.

(** Proof of point equality properties  *)
From Schnorr Require Export Schnorr_Abstract_structures.

Lemma plus_eq_compat_l' { T : Type} `{field : t_Field T}: forall x y z : T,
  x = y -> x + z = y + z.
Proof. apply plus_eq_compat_l. Qed.


Theorem p_eq_refl {T : Type} `{field : t_Field T} (p : t_Point T) : 
  PartialEq_f_eq p p = true.
Proof.
  unfold PartialEq_f_eq, t_PartialEq_527405312.
  destruct p; auto.
  apply andb_true_intro; split.
  - apply (partialEq_refl T).
  - apply (partialEq_refl T).
Qed.

Theorem p_eq_iff_partial_eq {T : Type} `{t_Sized T} `{t_Field T} (p1 p2 : t_Point T) : 
  PartialEq_f_eq p1 p2 = true <-> p1 = p2.
Proof.
  split.
  - unfold PartialEq_f_eq, t_PartialEq_527405312.
    destruct p1 as [|x1 y1], p2 as [|x2 y2]; auto; try discriminate.
    intros.
    apply andb_prop in H4; destruct H4.
    apply partialEq_iff_eq in H4.
    apply partialEq_iff_eq in H5.
    subst x1. subst y1.
    reflexivity.
  - destruct p1 as [|x1 y1], p2 as [|x2 y2]; auto; try discriminate.
    intros.
    inversion H4.
    subst x1. subst y1.
    apply p_eq_refl.
Qed.

Theorem p_neq_iff_not_partial_eq {T : Type} `{t_Sized T} `{t_Field T} (p1 p2 : t_Point T) :
  PartialEq_f_eq p1 p2 = false <-> p1 <> p2.
Proof.
  split; intros.
  - unfold not; intros.
    subst p2.
    rewrite p_eq_refl in H4.
    discriminate.
  - unfold not in H4.
    destruct (PartialEq_f_eq p1 p2) eqn:Heq; auto.
    exfalso. apply H4. apply p_eq_iff_partial_eq in Heq. apply Heq.
Qed.

Theorem p_ne_eq_relation {T : Type} `{t_Sized T} `{t_Field T} (p1 p2 : t_Point T) :
  PartialEq_f_ne p1 p2 = negb (PartialEq_f_eq p1 p2).
Proof.
  unfold PartialEq_f_ne, PartialEq_f_eq, t_PartialEq_527405312.
  destruct p1 as [|x1 y1], p2 as [|x2 y2]; auto; try discriminate.
Qed.

Theorem p_eq_iff_not_partial_ne {T : Type} `{t_Sized T} `{t_Field T} (p1 p2 : t_Point T) :
  PartialEq_f_ne p1 p2 = false <-> p1 = p2.
Proof.
  split; intros.
  - rewrite p_ne_eq_relation in H4.
    apply Bool.negb_false_iff in H4.
    apply p_eq_iff_partial_eq in H4.
    apply H4.
  - rewrite p_ne_eq_relation.
    apply Bool.negb_false_iff.
    subst p2.
    apply p_eq_refl.
Qed.

Theorem p_neq_iff_partial_ne {T : Type} `{t_Sized T} `{t_Field T} (p1 p2 : t_Point T) :
  PartialEq_f_ne p1 p2 = true <-> p1 <> p2.
Proof.
  split; intros.
  - unfold not; intros.
    subst p2.
    rewrite p_ne_eq_relation in H4.
    apply Bool.negb_true_iff in H4.
    rewrite p_eq_refl in H4.
    discriminate.
  - unfold not in H4.
    destruct (PartialEq_f_ne p1 p2) eqn:Heq; auto.
    exfalso. apply H4. apply p_eq_iff_not_partial_ne in Heq. apply Heq.
Qed. 