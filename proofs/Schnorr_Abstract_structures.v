(** 
	This file contains the Hax extraction of the scalar 
  and field trait definitions. We also prove several
  properties of the field and scalar traits.
*)


(* File automatically generated by Hacspec *)
From Coq Require Import ZArith.
Require Import List.
Import List.ListNotations.
(* Open Scope Z_scope. *)
Open Scope bool_scope.
Require Import Ascii.
Require Import String.
Require Import Coq.Floats.Floats.
From RecordUpdate Require Import RecordSet.
Import RecordSetNotations.
From Core Require Import Core.

(* NotImplementedYet *)

Open Scope N_scope.

(** * Field with Characteristic not equal to 2
  The properties of the field have been added manually since Hax does not support
  adding properties to traits.
*)

Class t_Field `{v_Self : Type} `{t_Sized (v_Self)} `{t_PartialEq (v_Self) (v_Self)} `{t_Clone (v_Self)} : Type :=
  {
    f_one : unit -> v_Self;
    f_zero : unit -> v_Self;
    f_add : v_Self -> v_Self -> v_Self;
    f_sub : v_Self -> v_Self -> v_Self;
    f_neg : v_Self -> v_Self;
    f_mul : v_Self -> v_Self -> v_Self;
    f_inv : v_Self -> v_Self;
    f_div : v_Self -> v_Self -> v_Self;


    add_comm : forall (x y : v_Self), f_add x y = f_add y x;
    add_assoc : forall (x y z : v_Self), f_add x (f_add y z) = f_add (f_add x y) z;
    add_zero_l : forall (x : v_Self), f_add (f_zero (tt)) x = x;
    add_neg_l : forall (x : v_Self), f_add x (f_neg x) = f_zero (tt);

    add_sub_eq : forall (x y : v_Self),  f_sub x y = f_add x (f_neg y);

    partialEq_iff_eq : forall (x y : v_Self), x = y <-> PartialEq_f_eq x y = true;
    paritalNe_iff_ne : forall (x y : v_Self), x <> y <-> PartialEq_f_ne x y = true;
    clone_id : forall (x : v_Self), Clone_f_clone x = x;

    mul_comm : forall (x y : v_Self), f_mul x y = f_mul y x;
    mul_assoc : forall (x y z : v_Self), f_mul x (f_mul y z) = f_mul (f_mul x y) z;
    mul_one_l : forall (x : v_Self), f_mul (f_one (tt)) x = x;
    mul_zero_l : forall (x : v_Self), f_mul (f_zero (tt)) x = f_zero (tt);
    mul_distrib_l : forall (x y z : v_Self), f_mul (f_add x y) z = f_add (f_mul x z) (f_mul y z);

    one_neq_zero : f_one (tt) <> f_zero (tt);

    mul_inv_l : forall (x : v_Self), x <> f_zero (tt) -> f_mul (f_inv x) x = f_one (tt);

    div_eq_mul_inv : forall (x y : v_Self), f_div x y = f_mul x (f_inv y);

    char_not_2 : f_add (f_one (tt)) (f_one (tt)) <> f_zero (tt);
  }.
Arguments t_Field:clear implicits.
Arguments t_Field (_) {_} {_} {_}.


(** * Scalar type isomorphic to the integers modulo a prime
  Several properties have been added manually to the scalar type class
  to enforce its isomorphism to the integers modulo a prime.
*)

Class t_Scalar `{v_Self : Type} `{t_Field (v_Self)} : Type :=
  {
    order : N;
    order_pos : 0 < order;
    valid_order_size : N.size order < v_WORDSIZE_64_;

    f_bits : v_Self -> t_usize;
    f_bit : v_Self -> t_usize -> bool;

    to_N : v_Self -> N;
    from_N : N -> v_Self;

    scalar_lt_size : forall (x : v_Self), to_N x < order;

    scalar_N_equiv_fwd : forall (x : v_Self), from_N (to_N x) = x;
    scalar_N_equiv_bwd : forall (x : N), to_N (from_N x) = N.modulo x order;

    f_bits_eq_N : forall (x : v_Self), f_bits x = (N.size (to_N x));
    f_bit_eq_N : forall (x : v_Self) (i : t_usize), f_bit x i = N.testbit (to_N x) (U64_f_v (usize_0 i));

    f_add_eq_N : forall (x y : v_Self), f_add x y = from_N (N.modulo (N.add (to_N x) (to_N y)) order);
    f_neg_eq_N : forall (x : v_Self), f_neg x = from_N (N.modulo (order - (to_N x)) order);
    f_sub_eq_N : forall (x y : v_Self), f_sub x y = from_N (N.modulo (N.sub (to_N x) (to_N y)) order);
    f_mul_eq_N : forall (x y : v_Self), f_mul x y = from_N (N.modulo (N.mul (to_N x) (to_N y)) order);
    f_zero_eq_N : to_N (f_zero (tt)) = 0;
    f_one_eq_N : to_N (f_one (tt)) = 1;
  }.
Arguments t_Scalar:clear implicits.
Arguments t_Scalar (_) {_} {_} {_} {_}.

Close Scope N_scope.


(** Notation *)
Declare Scope my_scope.

Notation "x + y" := (f_add x y) (at level 50, left associativity) : my_scope.
Notation "x - y" := (f_sub x y) (at level 50, left associativity) : my_scope.
Notation "x * y" := (f_mul x y) (at level 40, left associativity) : my_scope.
Notation "x / y" := (f_div x y) (at level 40, left associativity) : my_scope.
Notation "- x" := (f_neg x) (at level 35, right associativity) : my_scope.
Notation "x =? y" := (PartialEq_f_eq x y) (at level 70, no associativity) : my_scope.
Notation "x <>? y" := (PartialEq_f_ne x y) (at level 70, no associativity) : my_scope.
Notation "x < y" := (PartialOrd_f_lt x y) (at level 70, no associativity) : my_scope.
Notation "x <= y" := (PartialOrd_f_le x y) (at level 70, no associativity) : my_scope.
Notation "x >= y" := (PartialOrd_f_ge x y) (at level 70, no associativity) : my_scope.
Notation "x > y" := (PartialOrd_f_gt x y) (at level 70, no associativity) : my_scope.
Notation "x ^-1" := (f_inv x) (at level 35, right associativity) : my_scope.
Notation "0" := (f_zero tt) : my_scope.
Notation "1" := (f_one tt) : my_scope.
Notation "2" := (f_add (f_one tt) (f_one tt)) : my_scope.
Notation "3" := (f_add (f_one tt) (f_add (f_one tt) (f_one tt))) : my_scope.

Open Scope my_scope.

(** * Properties of Field and Scalar 
  This section proves several standard properties of a mathematical field.
*)

Require Import Ring Field.
Section FieldArithmetic.

Variable T : Type.
Context `{Sized : t_Sized T}`{PartialEq : t_PartialEq T T} `{Clone : t_Clone T}`{Field : @t_Field T Sized PartialEq Clone}.


Definition T_ring_theory : @ring_theory T (f_zero tt) (f_one tt) f_add f_mul f_sub f_neg eq :=
    mk_rt 
        (f_zero tt) 
        (f_one tt) 
        f_add 
        f_mul 
        f_sub 
        f_neg 
        (@eq T)
        add_zero_l
        add_comm
        add_assoc
        mul_one_l
        mul_comm
        mul_assoc
        mul_distrib_l
        add_sub_eq
        add_neg_l
.

Definition T_field_theory : @field_theory T (f_zero tt) (f_one tt) f_add f_mul f_sub f_neg f_div f_inv eq :=
    @mk_field 
        T
        (f_zero tt) 
        (f_one tt) 
        f_add 
        f_mul 
        f_sub 
        f_neg 
        f_div 
        f_inv 
        (@eq T)
        T_ring_theory
        one_neq_zero
        div_eq_mul_inv
        mul_inv_l
.

Add Field FField : T_field_theory.

Lemma partialEq_refl (x : T) : 
  PartialEq_f_eq x x = true.
Proof. intros. apply partialEq_iff_eq. reflexivity. Qed.

Lemma neq_iff_partialEq_false : forall x y : T,
    PartialEq_f_eq x y = false <-> x <> y.
Proof.
    intros.
    split; intro.
    - unfold not. intros contra. subst x. rewrite partialEq_refl in H. discriminate.
    - unfold not in H. destruct (PartialEq_f_eq x y) eqn:Heq.
      + apply partialEq_iff_eq in Heq. apply H in Heq. destruct Heq.
      + reflexivity.
Qed.

Theorem partial_eq_comm:  forall x y : T, 
  PartialEq_f_eq x y = PartialEq_f_eq y x.
Proof.
  intros. 
  destruct (PartialEq_f_eq x y) eqn:Heq.
  - apply partialEq_iff_eq in Heq. 
    subst x.
    symmetry.
    apply partialEq_refl.
  - symmetry.
    apply neq_iff_partialEq_false in Heq.
    apply neq_iff_partialEq_false.
    symmetry.
    apply Heq.
Qed.  

Theorem add_compat_r (x y z : T) :
  x = y -> x + z = y + z.
Proof. intros. subst x. reflexivity. Qed.

Theorem add_compat_l (x y z : T) :
  x = y -> z + x = z + y.
Proof. intros. subst x. reflexivity. Qed.

Lemma sub_eq_zero_iff_eq (x y : T) :
  f_sub x y = f_zero tt -> x = y.
Proof.
  intros.
  apply add_compat_r with (z := y) in H.
  rewrite add_zero_l in H.
  rewrite add_sub_eq in H.
  rewrite <- add_assoc in H.
  rewrite (add_comm (f_neg y) y) in H.
  rewrite add_neg_l in H.
  rewrite add_comm in H.
  rewrite add_zero_l in H.
  apply H.
Qed.


Theorem square_diff (x y : T) :
  (x - y) * (x + y) = x * x - y * y.
Proof. field. Qed.

Theorem neg_involutive (x : T) :
  -(-x) = x.
Proof. field. Qed.

Theorem neg_zero : -(0 : T) = (0 : T). Proof. field. Qed. 

Theorem add_eq_zero (x y : T) :
  x + y = 0 <-> x = -y.
Proof.
  split; intros.
  - apply (add_compat_r _ _ (-y)) in H.
    field [H].
  - apply (add_compat_l _ _ y) in H.
    rewrite add_neg_l in H.
    rewrite add_comm.
    apply H.
Qed.

Theorem square_eq_square (x y : T) :
  x * x = y * y <-> (x - y) * (x + y) = 0.
Proof.
  split; intros.
  - field [H].
  - rewrite <- (neg_involutive (y * y)).
    apply add_eq_zero.
    rewrite square_diff in H.
    rewrite <- add_sub_eq.
    apply H.
Qed.

Theorem mul_compat_r (x y z : T) :
  x = y -> x * z = y * z.
Proof. intros. subst x. reflexivity. Qed.

Theorem mul_compat_l (x y z : T) :
  x = y -> z * x = z * y.
Proof. intros. subst x. reflexivity. Qed.

Theorem mul_zero_r (x : T) :
  x * 0 = 0.
Proof. field. Qed.

Theorem mul_one_r {v_F : Type} `{t_Field (v_F)} (x : v_F) :
  x * 1 = x.
Proof. rewrite mul_comm. apply mul_one_l. Qed.

Theorem mul_inv_r (x : T) :
  x <> 0 -> x * (f_inv x) = 1.
Proof. intros Hx. rewrite mul_comm. rewrite mul_inv_l; auto. Qed.

Theorem f_mul_neq_zero (x y : T) :
  x <> 0 -> y <> 0 -> x * y <> 0.
Proof.
  intros Hx Hy.
  unfold not.
  intros Heq.
  apply (mul_compat_r _ _ (f_inv y)) in Heq.
  rewrite mul_zero_l in Heq.
  rewrite <- mul_assoc in Heq.
  rewrite mul_inv_r in Heq; auto.
  apply (mul_compat_l _ _ (f_inv x)) in Heq.
  rewrite mul_zero_r in Heq.
  rewrite mul_assoc in Heq.
  rewrite mul_inv_l in Heq; auto.
  rewrite mul_one_r in Heq.
  apply one_neq_zero.
  apply Heq.
Qed.

Theorem f_mul_eq_zero (x y : T) :
  x * y = 0 <-> x = 0 \/ y = 0.
Proof.
  split; intros.
  - destruct (x =? 0) eqn:Hx.
    + apply partialEq_iff_eq in Hx; auto.
    + apply neq_iff_partialEq_false in Hx.
      destruct (y =? 0) eqn:Hy.
      * apply partialEq_iff_eq in Hy; auto.
      * apply neq_iff_partialEq_false in Hy.
        apply f_mul_neq_zero in H; auto.
        destruct H.
  - destruct H.
    + rewrite H. 
      rewrite mul_zero_l.
      reflexivity.
    + rewrite H.
      rewrite mul_zero_r.
      reflexivity.
Qed.

Theorem f_neq_mul_neq (x y : T) : 
  - x * - y = x * y.
Proof. field. Qed.

Theorem f_sub_eq_zero (x y : T) :
  x - y = 0 <-> x = y.
Proof.
  split; intros.
  - rewrite add_sub_eq in H.
    rewrite add_eq_zero in H.
    rewrite neg_involutive in H.
    apply H.
  - rewrite add_sub_eq.
    rewrite add_eq_zero.
    rewrite neg_involutive.
    apply H.
Qed.

Theorem neg_eq_equiv (x y : T) :
  x = y <-> -x = -y.
Proof. split; intros; field [H]. Qed.


Lemma eq_neg_iff_zero : forall x : T,
  x = - x <-> x = 0.
Proof.
  split; intros.
  - rewrite <- add_eq_zero in H.
    rewrite <- (mul_one_l x) in H.
    rewrite <- mul_distrib_l in H.
    pose proof char_not_2 as Hneq2.
    apply (mul_compat_l (2 * x) 0 (f_inv 2)) in H.
    rewrite mul_assoc in H.
    rewrite mul_inv_l in H; auto.
    rewrite mul_one_l in H.
    rewrite mul_zero_r in H.
    apply H.
  - subst x.
    rewrite <- add_zero_l.
    rewrite add_neg_l.
    reflexivity.
Qed.  

Lemma neq_neg_iff_neq_zero : forall x : T,
  x <> - x <-> x <> 0.
Proof.
  split; intros.
  - unfold not in *.
    intros contra.
    apply eq_neg_iff_zero in contra.
    apply H. apply contra.
  - unfold not in *.
    intros contra.
    apply eq_neg_iff_zero in contra.
    apply H. apply contra.
Qed.

Lemma plus_eq_compat_l : forall x y z : T,
  x = y -> x + z = y + z.
Proof.
  intros. subst x. reflexivity.
Qed.

Theorem neq_iff_diff_neq_zero : forall x y : T,
  x <> y <-> x - y <> 0.
Proof.
  intros.
  split; intro H.
  - unfold not in *. intros. apply H. apply (plus_eq_compat_l _ _ y) in H0. 
    rewrite add_zero_l in H0. 
    rewrite add_comm in H0. 
    rewrite add_sub_eq in H0.
    rewrite add_assoc in H0.
    rewrite (add_comm y x) in H0.
    rewrite <- add_assoc in H0.
    rewrite add_neg_l in H0.
    rewrite add_comm in H0.
    rewrite add_zero_l in H0.
    apply H0.
  - unfold not in *. intros. apply H. subst x.
    rewrite add_sub_eq. apply add_neg_l.
Qed.

Lemma mul_sub_distr (x y z : T) :
  x * (y - z) = x * y - x * z.
Proof.
  field.
Qed.

Lemma mul_div_move_r (x y z : T) :
  y <> 0 ->
  x * y = z -> x = z / y.
Proof.
  intros Hy H.
  subst.
  rewrite div_eq_mul_inv.
  rewrite <- mul_assoc.
  rewrite mul_inv_r.
  rewrite mul_one_r.
  reflexivity.
  apply Hy.
Qed.

Lemma div_sub_comm (a b c d: T) :
  d <> c ->
  (a - b) / (c - d) = (b - a) / (d - c). 
Proof.
  intros.
  field.
  split.
  - apply -> neq_iff_diff_neq_zero. apply H.
  - apply -> neq_iff_diff_neq_zero. 
    apply not_eq_sym.
    apply H.
Qed.  
  
End FieldArithmetic.

(** * Isomorphism properties
  This section proves some properties about the isomporphism of the scalar type
  to the integers modulo a prime. 
*)

Lemma to_N_mod {T : Type} `{t_Scalar T} : forall x : T,
  to_N x = N.modulo (to_N x) order.
Proof.
  intros.
  rewrite <- (scalar_N_equiv_fwd x).
  rewrite scalar_N_equiv_bwd.
  rewrite N.Div0.mod_mod.
  reflexivity.
Qed.

Lemma from_N_mod {T : Type} `{t_Scalar T} : forall x : N,
  from_N x = from_N (N.modulo x order).
Proof.
  intros.
  rewrite <- (scalar_N_equiv_fwd (from_N x)).
  rewrite scalar_N_equiv_bwd.
  reflexivity.
Qed.

Lemma from_N_zero {T : Type} `{t_Scalar T} : 
  from_N 0 = f_zero tt.
Proof.
  rewrite <- f_zero_eq_N.
  rewrite scalar_N_equiv_fwd.
  reflexivity.
Qed.

Lemma to_N_zero {T : Type} `{t_Scalar T} : 
  to_N (f_zero tt) = 0%N.
Proof.
  rewrite f_zero_eq_N.
  reflexivity.
Qed.

Lemma to_N_equiv {T : Type} `{t_Scalar T} : forall x y : T,
  to_N x = to_N y -> x = y.
Proof.
  intros.
  rewrite <- scalar_N_equiv_fwd.
  rewrite <- (scalar_N_equiv_fwd x).
  rewrite H4.
  rewrite scalar_N_equiv_fwd.
  reflexivity.
Qed.

Lemma neq_zero {T : Type} `{t_Scalar T} : forall x : T,
  x <> f_zero tt -> to_N x <> 0%N.
Proof.
  unfold not.
  intros x Hx contra.
  apply Hx.
  rewrite <- to_N_zero in contra.
  apply to_N_equiv in contra.
  apply contra.
Qed.
  