(**
  This file contains the Hax extraction of the elliptic curve implementation
  and proves several properties of the elliptic curve operations.
*)


(* File automatically generated by Hacspec *)
From Coq Require Import ZArith.
Require Import List.
Import List.ListNotations.
Open Scope Z_scope.
Open Scope bool_scope.
Require Import Ascii.
Require Import String.
Require Import Coq.Floats.Floats.
From RecordUpdate Require Import RecordSet.
Import RecordSetNotations.
From Core Require Import Core.

(* NotImplementedYet *)

Require Import Lia.

From Schnorr Require Import Schnorr_Point.
From Schnorr Require Import Schnorr_Abstract_structures.
From Schnorr Require Import FoldRange.

Definition is_on_curve `{v_F : Type} `{t_Sized (v_F)} `{t_Field (v_F)} (a : v_F) (b : v_F) (p : t_Point v_F) : bool :=
  match p with
  | Point_Infinity => (true : bool)
  | Point_Affine x y =>
    let lhs := f_mul y y in
    let rhs := f_add (f_add (f_mul x (f_mul x x)) (f_mul a x)) b in
    PartialEq_f_eq lhs rhs
  end.

Definition ec_add  `{v_F : Type} `{t_Sized v_F} `{t_Field v_F}  (a : v_F) (e_b : v_F) (p q : t_Point v_F) : t_Point v_F :=
  match (p,q) with
  | (Point_Infinity,_) => Clone_f_clone (q)
  | (_,Point_Infinity) => Clone_f_clone (p)
  | (Point_Affine (x1) (y1),Point_Affine (x2) (y2)) =>
    if
      andb (PartialEq_f_eq (x1) (x2)) (PartialEq_f_eq (y1) (f_neg (y2)))
    then
      Point_Infinity
    else
      if
        andb (PartialEq_f_eq (x1) (x2)) (PartialEq_f_eq (y1) (y2))
      then
        let two := f_add (f_one (tt)) (f_one (tt)) in
        let three := f_add (f_one (tt)) (two) in
        let m := f_div (f_add (f_mul (three) (f_mul (x1) (x1))) (a)) (f_mul (two) (y1)) in
        let x3 := f_sub (f_sub (f_mul (m) (m)) (x1)) (x2) in
        let y3 := f_sub (f_mul (m) (f_sub (x1) (x3))) (y1) in
        Point_Affine x3 y3
      else
        let m := f_div (f_sub (y2) (y1)) (f_sub (x2) (x1)) in
        let x3 := f_sub (f_sub (f_mul (m) (m)) (x1)) (x2) in
        let y3 := f_sub (f_mul (m) (f_sub (x1) (x3))) (y1) in
        Point_Affine x3 y3
  end.

Definition ec_mul `{v_F : Type} `{v_S : Type} `{t_Sized (v_F)} `{t_Sized (v_S)} `{t_Field (v_F)} `{t_Scalar (v_S)} (a : v_F) (b : v_F) (p : t_Point ((v_F))) (n : v_S) : t_Point ((v_F)) :=
  let res := Point_Infinity in
  let bits := f_bits (n) in
  let res := fold_range 
    ((0 : t_usize)) 
    (bits) 
    (fun res _ => (true : bool)) 
    (res) 
    (fun res i =>
      let res := ec_add (a) (b) (res) (res) in
      if
        f_bit (n) (Sub_f_sub (t_Sub := t_Sub_1064369889) (Sub_f_sub (t_Sub := t_Sub_1064369889) (bits) ((1 : t_usize))) (i))
      then
        let res := ec_add (a) (b) (res) (p) in
        res
      else
        res) in
  res.

(** Specification of scalar multiplication. Not generated by Hax. *)
Fixpoint ec_scalar_mul_nat `{F : Type} `{t_Sized F} `{t_Field F}  (a b : F)  (p : t_Point F) (n : nat) : t_Point F :=
match n with
| O => Point_Infinity
| S x => ec_add a b (ec_scalar_mul_nat a b p x) p
end.

Record t_EllipticCurve (v_F : Type) (v_S : Type) `{t_Sized v_F} `{t_Sized v_S} `{t_Field v_F} `{t_Scalar v_S} : Type :=
  {
    f_a : v_F;
    f_b : v_F;
    f_gen : t_Point v_F;
    f_h : v_S;

    (* The generator point is on the curve *)
    gen_is_on_curve : is_on_curve f_a f_b f_gen = true;

    (* The order of G is the modulus of the scalar type *)
    gen_order_n : 
      ec_scalar_mul_nat f_a f_b f_gen (N.to_nat order) = Point_Infinity 
      /\ forall m, (m < (N.to_nat order) /\ m <> 0)%nat ->   
        ec_scalar_mul_nat f_a f_b f_gen m <> Point_Infinity;

    (* Cofactor is positive *)
    cofactor_neq_0 : f_h <> f_zero tt;
  }.
Arguments Build_t_EllipticCurve {_} {_} {_} {_} {_} {_} {_} {_} {_} {_} {_} {_} {_} (_) (_) (_) (_) (_) (_) (_).
Arguments f_a {_} {_} {_} {_} {_} {_} {_} {_} {_} {_} {_} {_} {_} (_).
Arguments f_b {_} {_} {_} {_} {_} {_} {_} {_} {_} {_} {_} {_} {_} (_).
Arguments f_gen {_} {_} {_} {_} {_} {_} {_} {_} {_} {_} {_} {_} {_} (_).
Arguments f_h {_} {_} {_} {_} {_} {_} {_} {_} {_} {_} {_} {_} {_} (_).
Arguments gen_is_on_curve {_} {_} {_} {_} {_} {_} {_} {_} {_} {_} {_} {_} {_} (_).
Arguments gen_order_n  {_} {_} {_} {_} {_} {_} {_} {_} {_} {_} {_} {_} {_} (_).
Arguments cofactor_neq_0 {_} {_} {_} {_} {_} {_} {_} {_} {_} {_} {_}  {_} {_} (_).

Definition impl__new 
  `{v_F : Type} `{v_S : Type} `{t_Sized v_F} `{t_Sized v_S} `{t_Field v_F} `{t_Scalar v_S} 
   (a : v_F) (b : v_F) (g : t_Point v_F) (h : v_S) 
  `{ Hgen_is_one_curve : is_on_curve a b g = true }
  `{ Hgen_order_n : ec_scalar_mul_nat a b g (N.to_nat order) = Point_Infinity /\ forall m, (m < (N.to_nat order)/\ m <> 0)%nat -> ec_scalar_mul_nat a b g m <> Point_Infinity }
  `{ Hcofactor_neq_0 : h <> f_zero tt }
      : t_EllipticCurve v_F v_S :=
   Build_t_EllipticCurve a b g h Hgen_is_one_curve Hgen_order_n Hcofactor_neq_0.

Definition impl__generator `{v_F : Type} `{v_S : Type} `{t_Sized v_F} `{t_Sized v_S} `{t_Field v_F} `{t_Scalar v_S} (self : t_EllipticCurve v_F v_S) : t_Point v_F :=
  f_gen self.

Definition impl__h `{v_F : Type} `{v_S : Type} `{t_Sized v_F} `{t_Sized v_S} `{t_Field v_F} `{t_Scalar v_S} (self : t_EllipticCurve v_F v_S) : v_S :=
  f_h self.

Definition impl__is_on_curve `{v_F : Type} `{v_S : Type} `{t_Sized v_F} `{t_Sized v_S} `{t_Field v_F} `{t_Scalar v_S} (self : t_EllipticCurve v_F v_S) (p : t_Point v_F) : bool :=
  is_on_curve (f_a self) (f_b self) (p).

Definition impl__is_infinity `{v_F : Type} `{v_S : Type} `{t_Sized v_F} `{t_Sized v_S} `{t_Field v_F} `{t_Scalar v_S} (self : t_EllipticCurve v_F v_S) (p : t_Point v_F) : bool :=
  match p with
  | Point_Infinity => (true : bool)
  | _ => (false : bool)
  end.

Definition impl__add `{v_F : Type} `{v_S : Type} `{t_Sized v_F} `{t_Sized v_S} `{t_Field v_F} `{t_Scalar v_S}  (self : t_EllipticCurve v_F v_S) (p q : t_Point v_F)  : t_Point v_F :=
  ec_add (f_a self) (f_b self) (p) (q).

Definition impl__mul `{v_F : Type} `{v_S : Type} `{t_Sized v_F} `{t_Sized v_S}  `{t_Field v_F} `{t_Scalar v_S} (self : t_EllipticCurve v_F v_S)  (p : t_Point v_F) (n : v_S) : t_Point ((v_F)) :=
  ec_mul (f_a self) (f_b self) (p) (n).


Definition impl__neg `{v_F : Type} `{v_S : Type} `{t_Sized (v_F)} `{t_Sized (v_S)} `{t_Field (v_F)} `{t_Scalar (v_S)} (self : t_EllipticCurve ((v_F)) ((v_S))) (p : t_Point ((v_F))) : t_Point ((v_F)) :=
  match p with
  | Point_Infinity => Point_Infinity
  | Point_Affine (x) (y) => Point_Affine (x) (f_neg (y))
  end.

(* -------------------------------- End of auto generated ----------------------------- *)


Require Import Ring Field.

Section EllipticCurve.
  
(** Notation *)
Declare Scope field_scope.

Notation "x =? y" := (PartialEq_f_eq x y) (at level 70, no associativity) : field_scope.
Notation "x + y" := (f_add x y) (at level 50, left associativity) : field_scope.
Notation "x - y" := (f_sub x y) (at level 50, left associativity) : field_scope.
Notation "x * y" := (f_mul x y) (at level 40, left associativity) : field_scope.
Notation "x / y" := (f_div x y) (at level 40, left associativity) : field_scope.
Notation "- x" := (f_neg x) (at level 35, right associativity) : field_scope.
Notation "0" := (f_zero tt) : field_scope.
Notation "1" := (f_one tt) : field_scope.
Notation "2" := (f_add (f_one tt) (f_one tt)) : field_scope.
Notation "3" := (f_add (f_one tt) (f_add (f_one tt) (f_one tt))) : field_scope.

Open Scope field_scope.

Variable A : Type.  
Context `{t_Sized_A : t_Sized A}.
Context `{t_Clone_A : t_Clone A}.
Context `{t_PartialEq_A : t_PartialEq A A}.
Context `{field_A : @t_Field A t_Sized_A t_PartialEq_A t_Clone_A}.
Context `{scalar_A : @t_Scalar A t_Sized_A t_PartialEq_A t_Clone_A field_A}.

Variable F : Type.  
Context `{t_Sized_F : t_Sized F}.
Context `{t_Clone_F : t_Clone F}.
Context `{t_PartialEq_F : t_PartialEq F F}.
Context `{field_F : @t_Field F t_Sized_F t_PartialEq_F t_Clone_F}.

Variable curve : t_EllipticCurve F A.


Definition F_ring_theory : @ring_theory F (f_zero tt) (f_one tt) f_add f_mul f_sub f_neg eq :=
    mk_rt 
        (f_zero tt) 
        (f_one tt) 
        f_add 
        f_mul 
        f_sub 
        f_neg 
        (@eq F)
        add_zero_l
        add_comm
        add_assoc
        mul_one_l
        mul_comm
        mul_assoc
        mul_distrib_l
        add_sub_eq
        add_neg_l
.

Definition F_field_theory : @field_theory F (f_zero tt) (f_one tt) f_add f_mul f_sub f_neg f_div f_inv eq :=
    @mk_field 
        F
        (f_zero tt) 
        (f_one tt) 
        f_add 
        f_mul 
        f_sub 
        f_neg 
        f_div 
        f_inv 
        (@eq F)
        F_ring_theory
        one_neq_zero
        div_eq_mul_inv
        mul_inv_l
.

Add Field FField : F_field_theory.

(** * Group Properties of the Elliptic Curve *)

(** *** Addition with identity element *)
Theorem ec_add_inf_l (p : t_Point F) :
  impl__add curve Point_Infinity p = p.
Proof. destruct p as [|x y]; reflexivity. Qed.

Theorem ec_add_inf_r (p : t_Point F) :
  impl__add curve p Point_Infinity = p.
Proof. destruct p as [|x y]; reflexivity. Qed.

(** *** Addition closed on curve *)
(** Y Coordinate symmetric *)
Theorem ec_y_coords_symmetry (x y1 y2 a b: F) :
  y1 * y1 = x * (x * x) + a * x + b ->
  y2 * y2 = x * (x * x) + a * x + b ->
  y1 = y2 \/ y1 = -y2.
Proof.
  intros.
  rewrite <- H0 in H.
  apply square_eq_square in H.
  apply f_mul_eq_zero in H.
  destruct H as [H|H].
  - left. rewrite f_sub_eq_zero in H. auto.
  - right.
    rewrite add_comm in H.
    rewrite add_eq_zero in H.
    rewrite neg_eq_equiv.
    rewrite neg_involutive.
    auto.
Qed.

Theorem ec_general_case : forall x1 y1 x2 y2 a b : F,
    x2 - x1 <> 0 ->
    y1 * y1 = x1 * (x1 * x1) + a * x1 + b ->
    y2 * y2 = x2 * (x2 * x2) + a * x2 + b ->
    ((y2 - y1) / (x2 - x1) * (x1 - ((y2 - y1) / (x2 - x1) * ((y2 - y1) / (x2 - x1)) - x1 -
    x2)) - y1) *
    ((y2 - y1) / (x2 - x1) * (x1 - ((y2 - y1) / (x2 - x1) * ((y2 - y1) / (x2 - x1)) - x1 -
    x2)) - y1) =
    ((y2 - y1) / (x2 - x1) * ((y2 - y1) / (x2 - x1)) - x1 - x2) *
    (((y2 - y1) / (x2 - x1) * ((y2 - y1) / (x2 - x1)) - x1 - x2) *
    ((y2 - y1) / (x2 - x1) * ((y2 - y1) / (x2 - x1)) - x1 - x2)) +
    a * ((y2 - y1) / (x2 - x1) * ((y2 - y1) / (x2 - x1)) - x1 - x2) + b.
Proof.
    intros.
    field [H0 H1].
    auto.
Qed.

Theorem ec_tangent_case : forall x1 y1 a b : F,
  y1 <> 0 -> 2 <> 0 ->
  y1 * y1 = x1 * (x1 * x1) + a * x1 + b ->
  ((3 * (x1 * x1) + a) / (2 * y1) * (x1 - ((3 * (x1 * x1) + a) / (2 * y1) * ((3 * (x1 * x1) + a) / (2 * y1)) - x1 - x1)) - y1) * ((3 * (x1 * x1) + a) / (2 * y1) * (x1 - ((3 * (x1 * x1) + a) / (2 * y1) * ((3 * (x1 * x1) + a) / (2 * y1)) - x1 - x1)) - y1) 
  = ((3 * (x1 * x1) + a) / (2 * y1) * ((3 * (x1 * x1) + a) / (2 * y1)) - x1 - x1) * (((3 * (x1 * x1) + a) / (2 * y1) * ((3 * (x1 * x1) + a) / (2 * y1)) - x1 - x1) * ((3 * (x1 * x1) + a) / (2 * y1) * ((3 * (x1 * x1) + a) / (2 * y1)) - x1 - x1)) + a * ((3 * (x1 * x1) + a) / (2 * y1) * ((3 * (x1 * x1) + a) / (2 * y1)) - x1 - x1) + b.
Proof.
    intros.
    field [H1].
    auto.
Qed.

Theorem ec_add_closed (p q : t_Point F) :
  impl__is_on_curve curve p = true ->
  impl__is_on_curve curve q = true ->
  impl__is_on_curve curve (impl__add curve p q) = true.
Proof.
  intros Hp Hq.
  destruct p as [|x1 y1]; destruct q as [|x2 y2].
  - reflexivity.
  - rewrite ec_add_inf_l. assumption.
  - rewrite ec_add_inf_r. assumption.
  - unfold impl__add, ec_add, impl__is_on_curve, is_on_curve; simpl.
    apply partialEq_iff_eq in Hq.
    apply partialEq_iff_eq in Hp.
    remember (f_a curve) as a.
    remember (f_b curve) as b.
    destruct (x1 =? x2) eqn:Heqx.
    + apply partialEq_iff_eq in Heqx; subst x2. 
      pose proof (ec_y_coords_symmetry x1 y1 y2 a b Hp Hq) as Hy.
      destruct Hy as [Hy|Hy].
      * subst y2; simpl. 
        destruct (y1 =? f_neg y1) eqn:Hy; auto.
        rewrite (partialEq_refl F).
        apply partialEq_iff_eq.
        apply ec_tangent_case; auto.
        -- apply (neq_iff_partialEq_false F) in Hy.
          apply neq_neg_iff_neq_zero in Hy. 
          apply Hy.
        -- apply char_not_2. 
      * subst y1; simpl.
        rewrite (partialEq_refl F).
        reflexivity.
    + simpl.
      rewrite (partial_eq_comm F) in Heqx.
      apply (neq_iff_partialEq_false F) in Heqx.
      apply (neq_iff_diff_neq_zero F) in Heqx.
      apply partialEq_iff_eq.
      apply ec_general_case; auto.
Qed.

(** *** Negation closed on curve *)
Theorem ec_neg_closed (p : t_Point F) :
  impl__is_on_curve curve p = true ->
  impl__is_on_curve curve (impl__neg curve p) = true.
Proof.
  simpl.
  intros.
  destruct p as [|x y] eqn:Ep; auto.
  simpl in *.
  apply partialEq_iff_eq in H.
  apply partialEq_iff_eq.
  rewrite f_neq_mul_neq.
  apply H.
Qed.

(** *** Addition Commutative *)
Theorem ec_add_comm_x_coord_aux : forall x1 y1 x2 y2  : F,
  x1 <> x2 ->
  ((((y2 - y1) / (x2 - x1)) * ((y2 - y1 ) / (x2 - x1))) - x1) - x2 = 
  ((((y1 - y2) / (x1 - x2)) * ((y1 - y2 ) / ( x1 - x2))) - x2) - x1.
Proof.
  intros.
  field.
  split.
  - apply (neq_iff_diff_neq_zero F) in H. auto.
  - apply not_eq_sym in H. apply (neq_iff_diff_neq_zero F) in H. auto.
Qed.

Theorem ec_add_comm_y_coord_aux : forall x1 y1 x2 y2 : F,
  x1 <> x2 ->
  (((y2 - y1) / (x2 - x1)) * (x1 - (((((y2 - y1) / (x2 - x1)) * ((y2 - y1) / (x2 - x1))) - x1) - x2))) - y1 =
  (((y1 - y2) / (x1 - x2)) * (x2 - (((((y1 - y2) / (x1 - x2)) * ((y1 - y2) / (x1 - x2))) - x2) - x1))) - y2.
Proof.
  intros.
  field.
  split.
  - apply (neq_iff_diff_neq_zero F) in H. auto.
  - apply not_eq_sym in H. apply (neq_iff_diff_neq_zero F) in H. auto. 
Qed.

Theorem ec_add_comm (p q : t_Point F) :
  impl__is_on_curve curve p = true ->
  impl__is_on_curve curve q = true ->
  impl__add curve p q = impl__add curve q p.
Proof.
  intros Hp Hq.
  destruct p as [|x1 y1] eqn:Ep, q as [|x2 y2] eqn:Eq; auto.
  unfold impl__add, ec_add; simpl.
  apply partialEq_iff_eq in Hp.
  apply partialEq_iff_eq in Hq.
  remember (f_a curve) as a.
  remember (f_b curve) as b.
  destruct (x1 =? x2) eqn:Heqx.
  - apply partialEq_iff_eq in Heqx; subst x2.
    pose proof (ec_y_coords_symmetry x1 y1 y2 a b Hp Hq) as Hy.
    destruct Hy as [Hy|Hy].
    + subst y2; simpl.
      repeat rewrite (partialEq_refl F); simpl.
      reflexivity.
    + subst y1; simpl.
      rewrite neg_involutive.
      repeat rewrite (partialEq_refl F); simpl.
      reflexivity.
  - rewrite (partial_eq_comm F x2 x1). rewrite Heqx. simpl.
    rewrite (neq_iff_partialEq_false F) in Heqx. 
    f_equal.
    + apply ec_add_comm_x_coord_aux; auto.
    + apply ec_add_comm_y_coord_aux; auto.  
Qed.

(** *** Additon Associativity *)
(** Admitted *)
Theorem ec_add_assoc (p q r : t_Point F) :
  impl__is_on_curve curve p = true ->
  impl__is_on_curve curve q = true ->
  impl__is_on_curve curve r = true ->
  impl__add curve (impl__add curve p q) r = impl__add curve p (impl__add curve q r).
Proof. Admitted.

(** *** Addition with identity *)
Theorem ec_add_id_l (p : t_Point F) :
  impl__is_on_curve curve p = true ->
  impl__add curve Point_Infinity p = p.
Proof. intros. apply ec_add_inf_l. Qed.

(** *** Addition with negation *)
Theorem ec_add_neg_l (p : t_Point F) :
  impl__is_on_curve curve p = true ->
  impl__add curve p (impl__neg curve p) = Point_Infinity.
Proof.
  intros Hp.
  destruct p as [| x y]; auto.
  unfold impl__neg, impl__add, ec_add.
  rewrite (partialEq_refl F).
  rewrite neg_involutive.
  rewrite (partialEq_refl F).
  simpl.
  reflexivity.
Qed.

Theorem ec_add_neg_r (p : t_Point F) :
  impl__is_on_curve curve p = true ->
  impl__add curve (impl__neg curve p) p = Point_Infinity.
Proof.
  intros Hp.
  destruct p as [| x y]; auto.
  unfold impl__neg, impl__add, ec_add.
  rewrite (partialEq_refl F).
  rewrite (partialEq_refl F).
  simpl.
  reflexivity.
Qed.

(** * Correctness of our implementation of scalar multiplication

    We prove the correctness of our implementation by definining 
    a specification and then proving that our implementation is equivalent
    to the specification. The specification is defined in terms of Rocq 
    unary numbers 'nat' as such we wrap this specification in a
    function 'scalar_mul_spec' that uses our scalar type 'A' instead.
*)
From Schnorr Require Import Binary_Nums.
From Schnorr Require Import HaxintSpec.

(** Scalar multiplication specification.
    
    We prove that this specification is equivalent to the
    one defined earlier. The one defined here is a bit simpler since
    it uses a curve. *)
Fixpoint scalar_mul_nat (p : t_Point F) (n : nat) : t_Point F :=
  match n with
  | O => Point_Infinity
  | S x => impl__add curve (scalar_mul_nat p x) p
  end.

Theorem ec_scalar_mul_nat_equiv (p : t_Point F) (n : nat) :
  scalar_mul_nat p n = ec_scalar_mul_nat (f_a curve) (f_b curve) p n.
Proof. 
  induction n; simpl; auto. rewrite IHn. unfold impl__add. reflexivity.
Qed.

Theorem scalar_mul_nat_closed (p : t_Point F) (n : nat) :
  impl__is_on_curve curve p = true ->
  impl__is_on_curve curve (scalar_mul_nat p n) = true.
Proof.
  intros Hp.
  induction n as [|n IHn].
  - simpl. reflexivity.
  - simpl. apply ec_add_closed.
    + apply IHn.
    + assumption.
Qed.

Definition scalar_mul_spec (p : t_Point F) (n : A) : t_Point F :=
  scalar_mul_nat p (N.to_nat (to_N n)).

Lemma simplify_range (n : positive) :
build_range 
  (unary_from_int (U64_f_v (usize_0 0%Z)))
  (unary_from_int (U64_f_v (usize_0 (Sub_f_sub  (t_Sub := t_Sub_1064369889) (N.size (POS_POS n mod order)) 0%Z)))) 
  LIST_NIL
= build_range
  0
  (N.to_nat (N.size (POS_POS n mod order) mod v_WORDSIZE_64_))
  LIST_NIL.
Proof.
  Local Opaque v_WORDSIZE_64_.
  simpl.
  unfold unary_from_int.
  repeat rewrite haxint_rem_spec.
  repeat rewrite haxint_add_spec.
  repeat rewrite haxint_sub_spec.
  rewrite N.Div0.mod_0_l.
  rewrite N.sub_0_r.
  rewrite N.Div0.mod_same.
  rewrite N.add_0_r.
  simpl.
  reflexivity.
Qed.

Lemma simplify_succ_index (n : positive) :
  N.size (Npos n) < v_WORDSIZE_64_ ->
  (Sub_f_sub (t_Sub := t_Sub_1064369889)
    (Sub_f_sub (t_Sub := t_Sub_1064369889)
      (N.succ (N.size (POS_POS n))) 
      1%Z) 
    (nat_to_usize (0 + N.to_nat (N.size (POS_POS n)))))
  = 0%Z.
Proof.
  Local Opaque v_WORDSIZE_64_.
  intros Hn.
  rewrite Nat.add_0_l.
  simpl.
  repeat rewrite haxint_rem_spec.
  repeat rewrite haxint_add_spec.
  repeat rewrite haxint_sub_spec.
  rewrite (N.mod_small 1 v_WORDSIZE_64_).
  rewrite (N.mod_small (v_WORDSIZE_64_ - 1) v_WORDSIZE_64_).
  unfold match_pos, positive_to_int.
  destruct (v_WORDSIZE_64_ - 1) eqn:E.
  + Local Transparent v_WORDSIZE_64_. unfold v_WORDSIZE_64_ in E. simpl in E. discriminate.
  + Local Opaque v_WORDSIZE_64_.
    rewrite positive_nat_N.
    rewrite (N.mod_small (Npos (Pos.size n)) v_WORDSIZE_64_).
    rewrite positive_add_spec.
    rewrite <- N.Div0.add_mod.
    rewrite N_pos_destruct.
    rewrite <- E.
    rewrite N_pos_succ.
    rewrite N.add_succ_comm.
    rewrite N.sub_1_r.
    rewrite N.succ_pred.
    rewrite <- N.Div0.add_mod_idemp_l.
    rewrite <- (N.Div0.add_mod_idemp_r _ v_WORDSIZE_64_ v_WORDSIZE_64_).
    rewrite N.Div0.mod_same.
    rewrite N.add_0_r.
    rewrite N.Div0.add_mod_idemp_l.
    rewrite (mod_inv_sub _ (Npos (Pos.size n)) v_WORDSIZE_64_ ).
    rewrite N.sub_diag.
    Local Transparent v_WORDSIZE_64_.
    * unfold v_WORDSIZE_64_. reflexivity.
    * apply N.le_refl.
    * apply N.lt_le_incl. apply Hn.
    * unfold v_WORDSIZE_64_. lia.
    * apply Hn.
  + apply N.sub_lt.
    * unfold v_WORDSIZE_64_. lia.
    * lia.
  + unfold v_WORDSIZE_64_. lia.
Qed.

Lemma test_bit_succ_xI : forall n i,
  N.testbit (Npos (xI n)) (U64_f_v (usize_0 (N.succ i))) = N.testbit (Npos n) (U64_f_v (usize_0 i)).
Proof.
  intros. simpl. destruct (N.succ i) eqn:E.
  - apply N.neq_succ_0 in E. destruct E.
  - rewrite N.pos_pred_spec. rewrite <- E. rewrite N.pred_succ. reflexivity.
Qed.

Lemma test_bit_succ_xO : forall n i,
  N.testbit (Npos (xO n)) (U64_f_v (usize_0 (N.succ i))) = N.testbit (Npos n) (U64_f_v (usize_0 i)).
Proof.
  intros. simpl. destruct (N.succ i) eqn:E.
  - apply N.neq_succ_0 in E. destruct E.
  - rewrite N.pos_pred_spec. rewrite <- E. rewrite N.pred_succ. reflexivity.
Qed.

Definition double (self : t_EllipticCurve F A) (p : t_Point F) : t_Point F :=
  impl__add self p p.

Theorem double_fold (self : t_EllipticCurve F A) (p : t_Point F) :
  double self p = impl__add self p p.
Proof. reflexivity. Qed.

Lemma ec_add_fold (p q : t_Point F) :
  ec_add (f_a curve) (f_b curve) p q = impl__add curve p q.
Proof. reflexivity. Qed.

Lemma scalar_mul_spec_double (p : t_Point F) (n : nat) :
  impl__is_on_curve curve p = true ->
  scalar_mul_nat p (n + n) = impl__add curve (scalar_mul_nat p n) (scalar_mul_nat p n).
Proof.
  intros Hp.
  induction n.
  - simpl. reflexivity.
  - pose proof scalar_mul_nat_closed p n Hp as H.
    pose proof ec_add_closed (scalar_mul_nat p n) (scalar_mul_nat p n) H H as H2.
    pose proof ec_add_closed p (scalar_mul_nat p n) Hp H as H3.
    pose proof ec_add_closed (scalar_mul_nat p n) p H Hp as H4.
    rewrite Nat.add_succ_r. 
    rewrite Nat.add_succ_l. 
    simpl. 
    rewrite IHn.
    rewrite (ec_add_assoc _ p p); auto.
    rewrite <- double_fold.
    rewrite <- double_fold.
    rewrite (ec_add_comm _  p) at 1; auto.
    rewrite ec_add_assoc; auto.
    rewrite <- (ec_add_assoc _ _ p); auto.
    rewrite <- double_fold.
    rewrite (ec_add_comm p _); auto.
    rewrite ec_add_assoc; auto.
    + unfold double. apply ec_add_closed; auto.
Qed.

Lemma bit_index_simpl : forall n i,
  N.size (Npos n) < v_WORDSIZE_64_ ->
  i < Npos (Pos.size n) ->
  Sub_f_sub (t_Sub := t_Sub_1064369889) 
    (Sub_f_sub (t_Sub := t_Sub_1064369889) 
      (N.succ (N.size (POS_POS n))) 
      1%Z) 
    i
  = N.succ (usize_to_haxint (Sub_f_sub (t_Sub := t_Sub_1064369889) 
    (Sub_f_sub (t_Sub := t_Sub_1064369889) 
      (N.size (POS_POS n)) 
      1%Z) 
    i)).
Proof.
  Local Opaque v_WORDSIZE_64_.
  intros.
  simpl in *.
  repeat rewrite haxint_rem_spec.
  repeat rewrite haxint_add_spec.
  repeat rewrite haxint_sub_spec.
  unfold match_pos, positive_to_int.
  rewrite (N.mod_small 1 v_WORDSIZE_64_) by lia.
  rewrite (N.mod_small i v_WORDSIZE_64_) by lia.
  rewrite (N.mod_small (v_WORDSIZE_64_ - 1) v_WORDSIZE_64_) by lia.
  rewrite wordsize_to_pos_pred.
  unfold usize_to_haxint.
  rewrite positive_add_spec.
  simpl.
  repeat rewrite N_pos_destruct.
  rewrite N_pos_succ.
  rewrite <- wordsize_to_pos_pred.
  rewrite (mod_inv_sub _ 1 _) by lia. 
  rewrite (mod_inv_sub _ 1 _) by lia.
  rewrite <- N.Div0.add_mod.
  rewrite <- N.Div0.add_mod.
  rewrite (mod_inv_sub _ i _) by lia.
  rewrite (mod_inv_sub _ i _) by lia.
  rewrite N.mod_small by lia.
  rewrite N.mod_small by lia.
  rewrite N.sub_succ_l by lia.
  rewrite N.sub_succ_l by lia.
  reflexivity.
Qed.  

(** *** Correctness Proofs *)
Theorem impl__mul_correctness_pos 
  (p : t_Point F) (n : positive) :
  impl__is_on_curve curve p = true -> 
  Npos n < order ->
  N.size (Npos n) < v_WORDSIZE_64_ ->
  impl__mul curve p (from_N (Npos n)) =
  scalar_mul_spec p (from_N (Npos n)).
Proof.
  Local Opaque v_WORDSIZE_64_.
  intros Hp Hn Hsize. 
  unfold impl__mul, ec_mul, scalar_mul_spec.
  rewrite f_bits_eq_N. 
  rewrite scalar_N_equiv_bwd.
  unfold fold_range.
  rewrite simplify_range.
  rewrite (N.mod_small (Npos n)) by assumption.
  induction n.
  - simpl in Hsize. pose proof Hsize as HxI.
    rewrite N_pos_succ in Hsize. apply N.lt_succ_l in Hsize. 
    rewrite (N.mod_small (N.size (Npos (POSITIVE_XI n))) v_WORDSIZE_64_ HxI).
    rewrite size_xI.
    rewrite Nnat.N2Nat.inj_succ.
    rewrite fold_left_build_range_succ.
    repeat rewrite ec_add_fold.
    rewrite <- double_fold.
    rewrite (simplify_succ_index n Hsize).
    rewrite f_bit_eq_N. 
    rewrite scalar_N_equiv_bwd.
    rewrite N.mod_small by assumption.
    simpl (N.testbit (POS_POS (POSITIVE_XI n)) (U64_f_v (usize_0 0%Z))).
    rewrite positive_N_nat in *.
    rewrite Pos2Nat.inj_xI.
    simpl (scalar_mul_nat p (UNARY_SUCC (2 * Pos.to_nat n))).
    rewrite Nat.add_0_r.
    f_equal.
    rewrite (scalar_mul_spec_double p (Pos.to_nat n) Hp).
    rewrite <- double_fold.
    f_equal.
    pose proof (lt_xI n order Hn) as HnxI.
    rewrite <- (IHn HnxI Hsize); clear IHn.
    rewrite (N.mod_small (N.size (Npos n)) v_WORDSIZE_64_ Hsize).
    apply fold_left_ext.
    intros acc [[i]] Hin.
    apply if_then_else_eq; auto.
    simpl in Hin.
    apply in_rev in Hin.
    apply in_build_range in Hin.
    destruct Hin as [Hin|Hin].
    + rewrite Nat.add_0_l in Hin.
      unfold usize_to_nat in Hin. 
      simpl in Hin.
      apply N2Nat_lt_Pos2Nat in Hin.
      repeat rewrite f_bit_eq_N.
      rewrite scalar_N_equiv_bwd.
      rewrite (bit_index_simpl n i); auto.
      rewrite N.mod_small by assumption.
      rewrite test_bit_succ_xI.
      rewrite scalar_N_equiv_bwd.
      rewrite N.mod_small by assumption.
      reflexivity.
    + simpl in Hin. destruct Hin.
  - simpl in Hsize. pose proof Hsize as HxO.
    rewrite N_pos_succ in Hsize. apply N.lt_succ_l in Hsize. 
    rewrite (N.mod_small (N.size (Npos (POSITIVE_XO n))) v_WORDSIZE_64_ HxO).
    rewrite size_xO.
    rewrite Nnat.N2Nat.inj_succ.
    rewrite fold_left_build_range_succ.
    repeat rewrite ec_add_fold.
    rewrite <- double_fold.
    rewrite (simplify_succ_index n Hsize).
    rewrite f_bit_eq_N.
    rewrite scalar_N_equiv_bwd.
    rewrite N.mod_small by assumption.
    simpl (N.testbit (POS_POS (POSITIVE_XO n)) (U64_f_v (usize_0 0%Z))).
    rewrite positive_N_nat in *.
    rewrite Pos2Nat.inj_xO.
    simpl (scalar_mul_nat p (2 * Pos.to_nat n)).
    rewrite Nat.add_0_r.
    rewrite (scalar_mul_spec_double p (Pos.to_nat n) Hp).
    rewrite <- double_fold.
    f_equal.
    pose proof (lt_xO n order Hn) as HnxO.
    rewrite <- (IHn HnxO Hsize); clear IHn.
    rewrite (N.mod_small (N.size (Npos n)) v_WORDSIZE_64_ Hsize).
    apply fold_left_ext.
    intros acc [[i]] Hin.
    apply if_then_else_eq; auto.
    simpl in Hin.
    apply in_rev in Hin.
    apply in_build_range in Hin.
    destruct Hin as [Hin|Hin].
    + rewrite Nat.add_0_l in Hin.
      unfold usize_to_nat in Hin. 
      simpl in Hin.
      apply N2Nat_lt_Pos2Nat in Hin.
      repeat rewrite f_bit_eq_N.
      rewrite scalar_N_equiv_bwd.
      rewrite (bit_index_simpl n i); auto.
      rewrite N.mod_small by assumption.
      rewrite test_bit_succ_xO.
      rewrite scalar_N_equiv_bwd.
      rewrite N.mod_small by assumption.
      reflexivity.
    + simpl in Hin. destruct Hin.
  - simpl (N.size 1).
    rewrite (N.mod_small 1 v_WORDSIZE_64_ Hsize).
    simpl ((List.rev (build_range 0 (N.to_nat 1) LIST_NIL))).
    simpl.
    rewrite f_bit_eq_N.
    rewrite scalar_N_equiv_bwd.
    rewrite N.mod_small by assumption.
    simpl.
    repeat rewrite haxint_rem_spec.
    repeat rewrite haxint_add_spec.
    repeat rewrite haxint_sub_spec.
    rewrite (N.mod_small 1 v_WORDSIZE_64_ Hsize).
    rewrite (N.mod_small (v_WORDSIZE_64_ - 1) v_WORDSIZE_64_ Hsize).
    unfold match_pos, match_positive, positive_to_int.
    rewrite N.sub_0_r.
    rewrite N.Div0.mod_same.
    rewrite N.Div0.mod_same.
    simpl.
    rewrite ec_add_fold.
    rewrite ec_add_inf_l.
    rewrite ec_add_inf_l.
    reflexivity.
Qed.
    
Theorem impl__mul_correctness  (p : t_Point F) (n : A) :
  impl__is_on_curve curve p = true ->
  impl__mul curve p n = scalar_mul_spec p n.
Proof.
  Local Opaque v_WORDSIZE_64_.
  intros Hp.
  rewrite <- (scalar_N_equiv_fwd n).
  destruct (to_N n) eqn:Heq.
  - unfold impl__mul, scalar_mul_spec, ec_mul. 
    rewrite f_bits_eq_N.
    rewrite scalar_N_equiv_bwd.
    reflexivity.
  - apply impl__mul_correctness_pos.
    + apply Hp.
    + rewrite <- Heq. apply scalar_lt_size.
    + rewrite <- Heq. 
      apply N.le_lt_trans with (m := N.size order).
      * apply lt_size_size. apply scalar_lt_size.
      * apply valid_order_size.
Qed.  

(** * Properties of scalar multiplication 
    The following section proves several properties of scalar
    multiplication that we will need to prove the correctness
    of the Schnorr protocol. *)
Theorem ec_mul_closed (p : t_Point F) (n : A) :
  impl__is_on_curve curve p = true ->
  impl__is_on_curve curve (impl__mul curve p n) = true.
Proof.
  intros Hp.
  rewrite impl__mul_correctness by assumption.
  apply scalar_mul_nat_closed.
  assumption.
Qed.

Lemma ec_mul_add_distr_nat (p : t_Point F) (x  y: nat) :
  impl__is_on_curve curve p = true ->
  scalar_mul_nat p (x + y) = 
  impl__add curve (scalar_mul_nat p x) (scalar_mul_nat p y).
Proof.
  intros Hp.
  induction x.
  - simpl. 
    rewrite ec_add_inf_l. 
    reflexivity.
  - simpl.
    rewrite ec_add_assoc.
    rewrite (ec_add_comm  p _).
    rewrite <- ec_add_assoc.
    f_equal.
    apply IHx.
    + apply scalar_mul_nat_closed; assumption.
    + apply scalar_mul_nat_closed; assumption.
    + assumption.
    + assumption.
    + apply scalar_mul_nat_closed; assumption.
    + apply scalar_mul_nat_closed; assumption.
    + assumption.
    + apply scalar_mul_nat_closed; assumption.
Qed.

Lemma ec_gen_mul_order  :
  impl__mul curve (impl__generator curve) (from_N order) = Point_Infinity.
Proof.
  rewrite impl__mul_correctness by apply gen_is_on_curve.
  unfold scalar_mul_spec.
  rewrite from_N_mod.
  rewrite N.Div0.mod_same.
  rewrite scalar_N_equiv_bwd.
  simpl.
  reflexivity.
Qed.

Lemma ec_mul_mul_nat (p : t_Point F) (x y : nat)  :
  impl__is_on_curve curve p = true ->
  scalar_mul_nat p (x * y) = 
  scalar_mul_nat (scalar_mul_nat p x) y.
Proof.
  intros Hp.
  induction y.
  - simpl. rewrite Nat.mul_0_r. reflexivity.
  - rewrite Nat.mul_succ_r.
    simpl.
    rewrite <- IHy.
    rewrite ec_mul_add_distr_nat.
    reflexivity.
    + apply Hp.
Qed.

Lemma scalar_mul_nat_inf (n : nat) :
  scalar_mul_nat Point_Infinity n = Point_Infinity.
Proof.
  induction n.
  - simpl. reflexivity.
  - simpl. rewrite IHn. rewrite ec_add_inf_l. reflexivity.
Qed.

Lemma scalar_mul_nat_gen_mul_order :
  scalar_mul_nat (impl__generator curve) (N.to_nat order) = Point_Infinity.
Proof. 
  pose proof (gen_order_n curve) as [H _].
  rewrite ec_scalar_mul_nat_equiv. 
  apply H.
Qed.

Lemma scalar_mul_nat_gen_mod_order (n : nat) :
  scalar_mul_nat (impl__generator curve) (n mod N.to_nat order) = 
  scalar_mul_nat (impl__generator curve) (n).
Proof.
  induction n.
  - simpl. rewrite Nat.mod_small. reflexivity. pose proof (order_pos). lia.
  - destruct (Nat_succ_mod n (N.to_nat order)) as [H|H]; unfold Nat.succ in *.
    + rewrite H. simpl. rewrite IHn. reflexivity.
    + rewrite H. apply Nat.Div0.mod_divides in H. 
      destruct H as [k Hk]. rewrite Hk. rewrite ec_mul_mul_nat by apply gen_is_on_curve. 
      rewrite scalar_mul_nat_gen_mul_order. rewrite scalar_mul_nat_inf. reflexivity.
Qed.

Lemma ec_mul_zero ( p : t_Point F) :
  impl__is_on_curve curve p = true ->  
  impl__mul curve p (f_zero tt) = Point_Infinity.
Proof.
  intros.
  rewrite impl__mul_correctness by assumption.
  unfold scalar_mul_spec.
  rewrite f_zero_eq_N.
  simpl.
  reflexivity.
Qed.

Lemma ec_gen_mul_add_distr  (x y : A) :
  impl__mul curve (impl__generator curve) (f_add x y) = 
  impl__add curve (impl__mul curve (impl__generator curve) x) (impl__mul curve (impl__generator curve) y).
Proof.
  rewrite impl__mul_correctness by apply gen_is_on_curve.
  rewrite impl__mul_correctness by apply gen_is_on_curve.
  rewrite impl__mul_correctness by apply gen_is_on_curve.
  unfold scalar_mul_spec.
  rewrite f_add_eq_N.
  rewrite <- from_N_mod.
  rewrite scalar_N_equiv_bwd.
  rewrite <- ec_mul_add_distr_nat by apply gen_is_on_curve.
  rewrite Nnat.N2Nat.inj_mod.
  rewrite <- Nnat.N2Nat.inj_add.
  fold scalar_mul_nat.
  rewrite scalar_mul_nat_gen_mod_order.
  reflexivity.
Qed.


  
Theorem ec_mul_gen_add_distr (x y : A) :
  impl__mul curve (impl__generator curve) (f_add x y) = 
  impl__add curve (impl__mul curve (impl__generator curve) x) (impl__mul curve (impl__generator curve) y).
Proof.
  rewrite impl__mul_correctness by apply gen_is_on_curve.
  rewrite impl__mul_correctness by apply gen_is_on_curve.
  rewrite impl__mul_correctness by apply gen_is_on_curve.
  unfold scalar_mul_spec.
  rewrite f_add_eq_N.
  rewrite <- from_N_mod.
  rewrite scalar_N_equiv_bwd.
  rewrite Nnat.N2Nat.inj_mod.
  rewrite scalar_mul_nat_gen_mod_order.
  rewrite <- ec_mul_add_distr_nat by apply gen_is_on_curve.
  rewrite Nnat.N2Nat.inj_add.
  reflexivity.
Qed.


Lemma ec_mul_pred_nat (p : t_Point F) (x : nat) :
  impl__is_on_curve curve p = true ->
  (x > 0)%nat ->
  scalar_mul_nat p (pred x) = 
  impl__add curve (scalar_mul_nat p x) (impl__neg curve p).
Proof.
  intros Hp.
  destruct x; simpl.
  - intros. lia.
  - intros. clear H.
    induction x; simpl.
    + rewrite ec_add_inf_l.
      rewrite ec_add_neg_l by assumption. 
      reflexivity.
    + rewrite IHx at 1.
      rewrite ec_add_comm.
      rewrite <- ec_add_assoc.
      rewrite (ec_add_comm p _).
      reflexivity.
      * assumption.
      * apply ec_add_closed; auto. 
        apply scalar_mul_nat_closed; auto.
      * assumption.
      * apply ec_add_closed; auto. 
        apply scalar_mul_nat_closed; auto.
      * apply ec_neg_closed. assumption.
      * repeat apply ec_add_closed; auto.
        apply scalar_mul_nat_closed; auto.
        apply ec_neg_closed. assumption.
      * assumption.
Qed.   


Theorem ec_add_neg_neg (p q : t_Point F) :
  impl__is_on_curve curve p = true ->
  impl__is_on_curve curve q = true ->
  impl__add curve (impl__neg curve p) (impl__neg curve q) =
  impl__neg curve (impl__add curve p q).
Proof.
  intros Hp Hq.
  destruct p as [|x1 y1] eqn:Ep, q as [|x2 y2] eqn:Eq; auto.
  unfold impl__neg, impl__add, ec_add.
  rewrite neg_involutive.
  destruct (PartialEq_f_eq x1 x2) eqn:Heqx.
  - apply partialEq_iff_eq in Heqx; subst x2.
    unfold impl__is_on_curve, is_on_curve in *.
    apply partialEq_iff_eq in Hp.
    apply partialEq_iff_eq in Hq.
    pose proof (ec_y_coords_symmetry x1 y1 y2 (f_a curve) (f_b curve) Hp Hq) as Hy.
    destruct Hy as [Hy|Hy].
    + subst y2; simpl.
      rewrite (partialEq_refl F).
      rewrite (partial_eq_comm F).
      destruct (PartialEq_f_eq y1 (f_neg y1)) eqn:Hy.
      * reflexivity.
      * rewrite (partialEq_refl F).
        apply (neq_iff_partialEq_false F) in Hy.
        f_equal.
        -- field. apply neq_neg_iff_neq_zero in Hy. split. apply Hy. split. apply char_not_2. intros contra. apply Hy. rewrite <- (neg_involutive F y1). rewrite contra. rewrite neg_zero. reflexivity.
        -- field. apply neq_neg_iff_neq_zero in Hy. split. apply Hy. split. apply char_not_2. intros contra. apply Hy. rewrite <- (neg_involutive F y1). rewrite contra. rewrite neg_zero. reflexivity.
    + subst y1.
      rewrite neg_involutive.
      rewrite (partialEq_refl F).
      rewrite (partialEq_refl F).
      reflexivity.
  - simpl. apply (neq_iff_partialEq_false F) in Heqx. f_equal.
    + field. apply not_eq_sym in Heqx.
      apply (neq_iff_diff_neq_zero F) in Heqx.
      apply Heqx.
    + field. apply not_eq_sym in Heqx.
      apply (neq_iff_diff_neq_zero F) in Heqx.
      apply Heqx.
Qed.

Lemma ec_mul_sub_distr_nat (p : t_Point F) (x  y: nat) :
  impl__is_on_curve curve p = true ->
  (x - y > 0)%nat ->
  scalar_mul_nat p (x - y) = 
  impl__add curve (scalar_mul_nat p x) (impl__neg curve (scalar_mul_nat p y)).
Proof.
  intros Hp Hxy.
  generalize dependent x.
  induction y; intros; simpl.
  - rewrite ec_add_inf_r.
    rewrite Nat.sub_0_r. 
    reflexivity.
  - rewrite Nat.sub_succ_r.
    rewrite ec_mul_pred_nat.
    rewrite IHy.
    rewrite ec_add_assoc.
    rewrite ec_add_neg_neg.
    reflexivity.
    + apply scalar_mul_nat_closed; assumption.
    + assumption.
    + apply scalar_mul_nat_closed; assumption.
    + apply ec_neg_closed. apply scalar_mul_nat_closed; assumption.
    + apply ec_neg_closed. assumption.
    + lia.
    + assumption.
    + lia.
Qed. 


Lemma ec_gen_mul_mul (x y : A) :
  impl__mul curve (impl__mul curve (impl__generator curve) x) y =
  impl__mul curve (impl__generator curve) (f_mul x y).
Proof.
  rewrite impl__mul_correctness.
  rewrite impl__mul_correctness by apply gen_is_on_curve.
  rewrite impl__mul_correctness by apply gen_is_on_curve.
  unfold scalar_mul_spec.
  rewrite f_mul_eq_N.
  rewrite scalar_N_equiv_bwd.
  rewrite N.Div0.mod_mod.
  rewrite Nnat.N2Nat.inj_mod.
  rewrite scalar_mul_nat_gen_mod_order.
  rewrite Nnat.N2Nat.inj_mul.
  rewrite ec_mul_mul_nat.
  reflexivity.
  - apply gen_is_on_curve.
  - apply ec_mul_closed; apply gen_is_on_curve.
Qed. 

Lemma ec_mul_fold (p : t_Point F) (n : A) :
  ec_mul (f_a curve) (f_b curve) p n = impl__mul curve p n.
Proof. reflexivity. Qed.

Lemma f_gen_fold  :
  impl__generator curve = f_gen curve.
Proof. reflexivity. Qed.

Lemma scalar_mul_nat_mul_order (k : nat):
  let p := scalar_mul_nat (impl__generator curve) k in 
  impl__is_on_curve curve p = true ->
  scalar_mul_nat p (N.to_nat order) = Point_Infinity.
Proof.
  intros.
  subst p.
  rewrite <- ec_mul_mul_nat by apply gen_is_on_curve.
  rewrite Nat.mul_comm.
  rewrite ec_mul_mul_nat by apply gen_is_on_curve.
  rewrite scalar_mul_nat_gen_mul_order.
  rewrite scalar_mul_nat_inf.
  reflexivity.
Qed.

Lemma scalar_mul_nat_mul_zero (p : t_Point F) :
  impl__is_on_curve curve p = true ->
  scalar_mul_nat p 0 = Point_Infinity.
Proof. reflexivity. Qed.

Lemma ec_mul_gen_mul_zero_iff_eq_inf (k : A) :
  impl__mul curve (impl__generator curve) k = Point_Infinity ->
  k = f_zero tt.
Proof.
  intros.
  destruct (PartialEq_f_eq k (f_zero tt)) eqn:E.
  - apply partialEq_iff_eq in E. apply E.
  - apply (neq_iff_partialEq_false A) in E.
    pose proof (gen_order_n curve) as [_ H1].
    rewrite impl__mul_correctness in H by apply gen_is_on_curve.
    unfold scalar_mul_spec in H.
    rewrite ec_scalar_mul_nat_equiv in H.
    apply H1 in H.
    inversion H.
    split.
    + rewrite to_N_mod. rewrite N2Nat_lt. apply N.mod_lt. pose proof order_pos. lia.
    + assert (forall n, n <> 0 -> N.to_nat n <> 0%nat) by lia.
      apply H0. apply neq_zero. apply E.
Qed.  

Lemma ec_neg_gen_mul (k : A) :
  impl__neg curve (impl__mul curve (impl__generator curve) k) = impl__mul curve (impl__generator curve) (f_neg k).
Proof.
  rewrite impl__mul_correctness by apply gen_is_on_curve.
  rewrite impl__mul_correctness by apply gen_is_on_curve.
  unfold scalar_mul_spec.
  rewrite f_neg_eq_N.
  rewrite scalar_N_equiv_bwd.
  rewrite N.Div0.mod_mod.
  destruct (to_N k =? 0) eqn:Hk.
  - apply N.eqb_eq in Hk.
    rewrite Hk.
    rewrite N.sub_0_r.
    rewrite N.Div0.mod_same.
    simpl.
    reflexivity.
  - apply N.eqb_neq in Hk.
    rewrite N.mod_small.
    rewrite Nnat.N2Nat.inj_sub.
    rewrite ec_mul_sub_distr_nat.
    rewrite scalar_mul_nat_gen_mul_order.
    rewrite ec_add_inf_l.
    reflexivity.
    + apply gen_is_on_curve.
    + assert (forall (n k : nat), (n - k > 0)%nat <-> (k < n)%nat) by lia. apply H. apply N2Nat_lt. rewrite to_N_mod. apply N.mod_lt. pose proof order_pos. lia.
    + pose proof order_pos. lia.
Qed.

Lemma ec_neg_mul  (v k : A) :
  let p := impl__mul curve (impl__generator curve) v in
  impl__is_on_curve curve p = true ->
  impl__neg curve (impl__mul curve p k) = impl__mul curve p (f_neg k).
Proof.
  simpl.
  intros.
  rewrite impl__mul_correctness by assumption.
  rewrite impl__mul_correctness by apply gen_is_on_curve.
  rewrite impl__mul_correctness.
  unfold scalar_mul_spec.
  rewrite f_neg_eq_N.
  rewrite scalar_N_equiv_bwd.
  rewrite N.Div0.mod_mod.
  destruct (to_N k =? 0) eqn:Hk.
  - apply N.eqb_eq in Hk.
    rewrite Hk.
    rewrite N.sub_0_r.
    rewrite N.Div0.mod_same.
    simpl.
    reflexivity.
  - apply N.eqb_neq in Hk.
    rewrite N.mod_small.
    rewrite Nnat.N2Nat.inj_sub.
    rewrite ec_mul_sub_distr_nat.
    rewrite scalar_mul_nat_mul_order.
    rewrite ec_add_inf_l.
    reflexivity.
    + apply scalar_mul_nat_closed. apply gen_is_on_curve.
    + apply scalar_mul_nat_closed. apply gen_is_on_curve.
    + assert (forall (n k : nat), (n - k > 0)%nat <-> (k < n)%nat) by lia. apply H0. apply N2Nat_lt. rewrite to_N_mod. apply N.mod_lt. pose proof order_pos. lia.
    + pose proof order_pos. lia.
  - apply scalar_mul_nat_closed; apply gen_is_on_curve. 
Qed.

Lemma ec_add_intros_r  (p q k : t_Point F):
  impl__is_on_curve curve p = true ->
  impl__is_on_curve curve q = true ->
  p = q ->
  impl__add curve p k = impl__add curve q k.
Proof.
  intros.
  subst.
  reflexivity.
Qed.

Lemma ec_mul_eq_iff_mod_n (x y : A) :
  impl__mul curve (impl__generator curve) x = impl__mul curve (impl__generator curve) y -> 
  x = y.
Proof. 
  intros Hxy.
  apply (ec_add_intros_r _ _ (impl__neg curve (impl__mul curve (impl__generator curve) y))) in Hxy.
  rewrite ec_add_neg_l in Hxy.
  rewrite (ec_neg_gen_mul y) in Hxy.
  rewrite <- ec_mul_gen_add_distr in Hxy.
  apply ec_mul_gen_mul_zero_iff_eq_inf in Hxy.
  rewrite <- add_sub_eq in Hxy.
  apply (sub_eq_zero_iff_eq A).
  apply Hxy.
  - apply ec_mul_closed. apply gen_is_on_curve.
  - apply ec_mul_closed; apply gen_is_on_curve.
  - apply ec_mul_closed. apply gen_is_on_curve.
Qed.     
  

Theorem ec_gen_mul_cofactor (x : A) :
  x <> f_zero tt ->
  impl__mul curve (impl__mul curve (impl__generator curve) x) (impl__h curve) <> Point_Infinity.
Proof.
  intros.
  rewrite ec_gen_mul_mul.
  pose proof (gen_order_n curve) as [H1 H2].
  rewrite impl__mul_correctness by apply gen_is_on_curve.
  unfold scalar_mul_spec.
  rewrite ec_scalar_mul_nat_equiv.
  apply H2.
  split.
  - rewrite N2Nat_lt. 
    rewrite to_N_mod. 
    apply N.mod_lt. 
    pose proof order_pos. 
    lia.
  - assert (forall n, n <> 0 -> N.to_nat n <> 0%nat) by lia.
    apply H0. 
    apply neq_zero.
    apply f_mul_neq_zero.
    + apply H.
    + pose proof (cofactor_neq_0 curve) as Hc. apply Hc.
Qed.

Theorem ec_add_move_r (a b c : t_Point F) :
  impl__is_on_curve curve a = true ->
  impl__is_on_curve curve b = true ->
  impl__is_on_curve curve c = true ->
  impl__add curve a b = c
  <-> a = impl__add curve c (impl__neg curve b).
Proof.
  intros Ha Hb Hc.
  split; intros H; subst.
  - rewrite ec_add_assoc.
    rewrite ec_add_neg_l.
    rewrite ec_add_inf_r.
    reflexivity. 
    all : auto.
    + apply ec_neg_closed; assumption. 
  - rewrite ec_add_assoc.
    rewrite ec_add_neg_r.
    rewrite ec_add_inf_r.
    reflexivity.
    all : auto.
    + apply ec_neg_closed; assumption.
Qed.

Theorem ec_add_move_l (a b c : t_Point F) :
  impl__is_on_curve curve a = true ->
  impl__is_on_curve curve b = true ->
  impl__is_on_curve curve c = true ->
  impl__add curve a b = c
  <-> b = impl__add curve (impl__neg curve a) c.
Proof.
  intros Ha Hb Hc.
  split; intros H; subst.
  - rewrite <- ec_add_assoc.
    rewrite ec_add_neg_r.
    rewrite ec_add_inf_l.
    reflexivity. 
    all : auto.
    + apply ec_neg_closed; assumption. 
  - rewrite <- ec_add_assoc.
    rewrite ec_add_neg_l.
    rewrite ec_add_inf_l.
    reflexivity.
    all : auto.
    + apply ec_neg_closed; assumption.
Qed.

End EllipticCurve.